/* automatically generated by rust-bindgen 0.71.1 */

unsafe extern "C" {
    pub fn XcpInit();
}
unsafe extern "C" {
    pub fn XcpSetEpk(epk: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn XcpDisconnect();
}
unsafe extern "C" {
    pub fn XcpEventExt(event: u16, base: *const u8) -> u8;
}
unsafe extern "C" {
    pub fn XcpEvent(event: u16);
}
unsafe extern "C" {
    pub fn XcpSendTerminateSessionEvent();
}
unsafe extern "C" {
    pub fn XcpPrint(str_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn XcpSetLogLevel(level: u8);
}
unsafe extern "C" {
    pub fn ApplXcpGetClock64() -> u64;
}
unsafe extern "C" {
    pub fn ApplXcpRegisterCallbacks(
        cb_connect: ::std::option::Option<unsafe extern "C" fn() -> bool>,
        cb_prepare_daq: ::std::option::Option<unsafe extern "C" fn() -> u8>,
        cb_start_daq: ::std::option::Option<unsafe extern "C" fn() -> u8>,
        cb_stop_daq: ::std::option::Option<unsafe extern "C" fn()>,
        cb_freeze_daq: ::std::option::Option<unsafe extern "C" fn(clear: u8, config_id: u16) -> u8>,
        cb_get_cal_page: ::std::option::Option<unsafe extern "C" fn(segment: u8, mode: u8) -> u8>,
        cb_set_cal_page: ::std::option::Option<unsafe extern "C" fn(segment: u8, page: u8, mode: u8) -> u8>,
        cb_freeze_cal: ::std::option::Option<unsafe extern "C" fn() -> u8>,
        cb_init_cal: ::std::option::Option<unsafe extern "C" fn(src_page: u8, dst_page: u8) -> u8>,
        cb_read: ::std::option::Option<unsafe extern "C" fn(src: u32, size: u8, dst: *mut u8) -> u8>,
        cb_write: ::std::option::Option<unsafe extern "C" fn(dst: u32, size: u8, src: *const u8, delay: u8) -> u8>,
        cb_flush: ::std::option::Option<unsafe extern "C" fn() -> u8>,
    );
}
unsafe extern "C" {
    pub fn ApplXcpSetA2lName(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Initialize the XCP on Ethernet server instance.\n @pre User has called XcpInit.\n @param address Address to bind to.\n @param port Port to bind to.\n @param use_tcp Use TCP if true, otherwise UDP.\n @param measurement_queue Optional external memory to place the measurement queue.\n Pass NULL if server should allocate it.\n @param measurement_queue_size Measurement queue size in bytes. Includes the bytes occupied by the queue header.\n @return True on success, otherwise false."]
    pub fn XcpEthServerInit(address: *const u8, port: u16, use_tcp: bool, measurement_queue: *mut ::std::os::raw::c_void, measurement_queue_size: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " Shutdown the XCP on Ethernet server instance."]
    pub fn XcpEthServerShutdown() -> bool;
}
unsafe extern "C" {
    #[doc = " Get the XCP on Ethernet server instance status.\n @return True if the server is running, otherwise false."]
    pub fn XcpEthServerStatus() -> bool;
}
unsafe extern "C" {
    pub fn XcpEthTlGetInfo(isTCP: *mut bool, mac: *mut u8, addr: *mut u8, port: *mut u16);
}
